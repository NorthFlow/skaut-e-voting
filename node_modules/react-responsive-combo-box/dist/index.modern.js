import React, { useState, useReducer, useRef, useEffect } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var initialState = {
  isFocus: false,
  focusIndex: -1
};

var focusReducer = function focusReducer(state, action) {
  switch (action.type) {
    case 'setFocusIndex':
      return _extends({}, state, {
        focusIndex: action.focusIndex
      });

    case 'toggleFocus':
      return _extends({}, state, {
        isFocus: action.isFocus
      });

    default:
      return state;
  }
};

var styles = {"comboBox":"_3tcyg","comboBoxInput":"_3LDgJ","comboBoxPopover":"_WbEAz","comboBoxList":"_r3jpc","comboBoxOption":"_2iQTD"};

var UP_ARROW = 38;
var DOWN_ARROW = 40;
var ENTER_KEY = 13;
var ESCAPE_KEY = 27;

var ComboBox = function ComboBox(_ref) {
  var comboBoxOptions = _ref.options,
      onChange = _ref.onChange,
      defaultValue = _ref.defaultValue,
      placeholder = _ref.placeholder,
      onSelect = _ref.onSelect,
      onOptionsChange = _ref.onOptionsChange,
      optionsListMaxHeight = _ref.optionsListMaxHeight,
      renderOptions = _ref.renderOptions,
      style = _ref.style,
      className = _ref.className,
      focusColor = _ref.focusColor,
      enableAutocomplete = _ref.enableAutocomplete,
      inputStyles = _ref.inputStyles,
      name = _ref.name,
      onBlur = _ref.onBlur,
      _ref$editable = _ref.editable,
      editable = _ref$editable === void 0 ? true : _ref$editable;
  var optionMaxHeight = optionsListMaxHeight || 200;
  var suggestionListPositionStyles = {};

  var _useState = useState(comboBoxOptions),
      options = _useState[0],
      setOptions = _useState[1];

  var _useState2 = useState(defaultValue || ''),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var _useReducer = useReducer(focusReducer, initialState),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var isFocus = state.isFocus,
      focusIndex = state.focusIndex;

  var _useState3 = useState(false),
      isMouseInsideOptions = _useState3[0],
      setIsMouseInsideOptions = _useState3[1];

  var _useState4 = useState(false),
      IsOptionsPositionedTop = _useState4[0],
      setIsOptionsPositionedTop = _useState4[1];

  var optionsContainerRef = useRef(null);
  var optionRef = useRef(null);
  useEffect(function () {
    if (!isFocus) setInputValue(defaultValue || '');
    dispatch({
      type: 'setFocusIndex',
      focusIndex: defaultValue ? options.indexOf(defaultValue.toString()) : -1
    });
  }, [defaultValue]);
  useEffect(function () {
    var _optionsContainerElem, _optionsContainerElem2;

    var optionsContainerElement = optionsContainerRef.current;
    var offsetBottom = window.innerHeight - (optionsContainerElement === null || optionsContainerElement === void 0 ? void 0 : (_optionsContainerElem = optionsContainerElement.offsetParent) === null || _optionsContainerElem === void 0 ? void 0 : _optionsContainerElem.getBoundingClientRect().top);

    if (optionMaxHeight > offsetBottom && (optionsContainerElement === null || optionsContainerElement === void 0 ? void 0 : (_optionsContainerElem2 = optionsContainerElement.offsetParent) === null || _optionsContainerElem2 === void 0 ? void 0 : _optionsContainerElem2.getBoundingClientRect().top) > offsetBottom) {
      setIsOptionsPositionedTop(true);
    } else {
      setIsOptionsPositionedTop(false);
    }
  }, [isFocus]);
  if (IsOptionsPositionedTop) suggestionListPositionStyles = {
    bottom: '100%',
    marginBottom: '5px'
  };else suggestionListPositionStyles = {
    top: '100%',
    marginTop: '5px'
  };

  var blurHandler = function blurHandler(event) {
    if (!isMouseInsideOptions) dispatch({
      type: 'toggleFocus',
      isFocus: false
    });
    if (onBlur) onBlur(event);
  };

  var updateValue = function updateValue(index) {
    if (index === void 0) {
      index = focusIndex;
    }

    if (index !== -1) {
      setInputValue(options[index]);
      if (onOptionsChange) onOptionsChange(options[index]);
    }
  };

  var resetFocusIndex = function resetFocusIndex() {
    comboBoxOptions.forEach(function (option, index) {
      if (option === options[focusIndex]) dispatch({
        type: 'setFocusIndex',
        focusIndex: index
      });
    });
  };

  var selectSuggestionHandler = function selectSuggestionHandler() {
    updateValue();
    dispatch({
      type: 'toggleFocus',
      isFocus: false
    });
    resetFocusIndex();
    setOptions(comboBoxOptions);
    if (onSelect) onSelect(options[focusIndex]);
  };

  var keyHandler = function keyHandler(event) {
    var optionsContainerElement = optionsContainerRef.current;
    var optionElement = optionRef.current;
    var newFocusIndex = focusIndex;

    switch (event.keyCode) {
      case DOWN_ARROW:
        {
          event.preventDefault();

          if (!isFocus) {
            dispatch({
              type: 'toggleFocus',
              isFocus: true
            });
            if (optionElement && optionsContainerElement) optionsContainerElement.scrollTop = optionElement.offsetTop - optionElement.offsetHeight;
          } else {
            if (focusIndex >= options.length - 1) {
              newFocusIndex = 0;
              optionsContainerElement.scrollTop = 0;
            } else {
                newFocusIndex = focusIndex + 1;

                if (optionElement && optionsContainerElement) {
                  var optionPosition = optionElement.offsetTop + optionElement.offsetHeight;
                  var optionsContainerPosition = optionsContainerElement.clientHeight + optionsContainerElement.scrollTop - optionElement.offsetHeight;

                  if (optionPosition >= optionsContainerPosition) {
                    optionsContainerElement.scrollTop += optionElement.offsetHeight;
                  }
                }
              }
          }

          dispatch({
            type: 'setFocusIndex',
            focusIndex: newFocusIndex
          });
          if (onOptionsChange) onOptionsChange(options[newFocusIndex]);
          optionsContainerRef.current = optionsContainerElement;
          break;
        }

      case UP_ARROW:
        {
          event.preventDefault();

          if (!isFocus) {
            dispatch({
              type: 'toggleFocus',
              isFocus: true
            });
            if (optionElement && optionsContainerElement) optionsContainerElement.scrollTop = optionElement.offsetTop - optionElement.offsetHeight;
          } else {
            if (focusIndex <= 0) {
              newFocusIndex = options.length - 1;
              if (optionsContainerElement) optionsContainerElement.scrollTop = optionsContainerElement.scrollHeight;
            } else {
              newFocusIndex = focusIndex - 1;

              if (optionElement && optionsContainerElement) {
                var _optionPosition = optionElement.offsetTop - optionElement.offsetHeight;

                if (_optionPosition <= optionsContainerElement.scrollTop) {
                  optionsContainerElement.scrollTop -= optionElement.offsetHeight;
                }
              }
            }
          }

          dispatch({
            type: 'setFocusIndex',
            focusIndex: newFocusIndex
          });
          if (onOptionsChange) onOptionsChange(options[newFocusIndex]);
          optionsContainerRef.current = optionsContainerElement;
          break;
        }

      case ENTER_KEY:
        {
          if (focusIndex > -1 && focusIndex < options.length) selectSuggestionHandler();
          break;
        }

      case ESCAPE_KEY:
        {
          event.target.blur();
          dispatch({
            type: 'toggleFocus',
            isFocus: false
          });
          break;
        }
    }
  };

  var filterSuggestion = function filterSuggestion(filterText) {
    if (filterText.length === 0) setOptions(comboBoxOptions);else {
      var filteredSuggestion = comboBoxOptions.filter(function (option) {
        return option.toLowerCase().indexOf(filterText.toLowerCase()) !== -1;
      });
      setOptions(filteredSuggestion);
    }
  };

  var inputChangeHandler = function inputChangeHandler(event) {
    if (onChange) onChange(event);
    setInputValue(event.target.value);
    if (enableAutocomplete) filterSuggestion(event.target.value);
  };

  var inputClickHandler = function inputClickHandler() {
    dispatch({
      type: 'toggleFocus',
      isFocus: true
    });
    dispatch({
      type: 'setFocusIndex',
      focusIndex: options.indexOf(inputValue.toString())
    });
  };

  var focusHandler = function focusHandler() {
    var optionsContainerElement = optionsContainerRef.current;
    var optionElement = optionRef.current;
    optionsContainerElement.scrollTop = optionElement === null || optionElement === void 0 ? void 0 : optionElement.offsetTop;
    dispatch({
      type: 'toggleFocus',
      isFocus: true
    });
  };

  var mouseEnterHandler = function mouseEnterHandler(index) {
    dispatch({
      type: 'setFocusIndex',
      focusIndex: index
    });
    if (onOptionsChange) onOptionsChange(options[index]);
  };

  return React.createElement("div", {
    className: styles.comboBox,
    style: style
  }, React.createElement("input", {
    onFocus: focusHandler,
    onChange: inputChangeHandler,
    placeholder: placeholder || '',
    onKeyDown: keyHandler,
    value: inputValue,
    className: styles.comboBoxInput,
    onBlur: blurHandler,
    name: name,
    style: _extends({}, inputStyles, {
      cursor: editable ? 'text' : 'default'
    }),
    readOnly: !editable,
    onClick: inputClickHandler
  }), React.createElement("div", {
    className: styles.comboBoxPopover,
    style: _extends({
      opacity: isFocus ? 1 : 0,
      visibility: isFocus ? 'visible' : 'hidden'
    }, suggestionListPositionStyles),
    ref: optionsContainerRef,
    onMouseEnter: function onMouseEnter() {
      return setIsMouseInsideOptions(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setIsMouseInsideOptions(false);
    }
  }, React.createElement("div", {
    className: styles.comboBoxList,
    style: {
      maxHeight: isFocus ? optionMaxHeight : 0
    }
  }, options.map(function (option, index) {
    return React.createElement("div", {
      className: className ? styles.comboBoxOption + " " + className : styles.comboBoxOption,
      key: option,
      ref: index === focusIndex ? optionRef : null,
      style: {
        backgroundColor: index === focusIndex ? focusColor || 'rgba(155,155,155,0.15)' : 'white',
        fontWeight: index === focusIndex ? 'bold' : 'normal'
      },
      onClick: function onClick() {
        return selectSuggestionHandler();
      },
      onMouseDown: function onMouseDown(e) {
        return e.preventDefault();
      },
      onMouseEnter: function onMouseEnter() {
        return mouseEnterHandler(index);
      }
    }, renderOptions ? renderOptions(option) : option);
  }))));
};

export default ComboBox;
//# sourceMappingURL=index.modern.js.map
